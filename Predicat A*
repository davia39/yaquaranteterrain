
:- module( decision, [
	init/1,
	move/2
] ).

:- use_module( data ).

% Recupere les coordonnées du robot lorsqu'il se déplace
% Incomplet

init(_):- nb_setval(openList, []), nb_setval(closedList, []), nb_setval(le_Chemin, []), nb_setval(color,0),	nb_setval(r1,[]), nb_setval(r2,[]), nb_setval(r3,[]),nb_setval(lPath,[]).


/*
  move( +L, -ActionId )
*/


deplacement([X,Y,Direction,X,Y|R]):-blocked([X,Y], Direction),!.
%deplacement(X,Y,1,X,Y,N, TL, TR, BL, BR, N) :- Pos is [X,Y], member(Pos, nb_getval(robotsPos)), writef('deplacement : %t\n',[N]), !. 

deplacement(X,Y,1,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,0), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,3,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,0), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,2,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,1), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,4,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,1), writef('deplacement : %t\n',[N]),!.

deplacement(X,Y, 1, NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, X1 is X+1, deplacement(X1,Y,1, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y, 3, NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, X1 is X-1, deplacement(X1,Y,3, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y, 2, NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, Y1 is Y+1, deplacement(X,Y1,2, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y, 4, NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, Y1 is Y-1, deplacement(X,Y1,4, NX,NY, N1, TL, TR, BL, BR,NBR).

deplacement(X,Y, D, NX, NY, TL, TR, BL, BR,NBR) :- deplacement(X,Y, D,NX, NY,0, TL, TR, BL, BR,NBR).



move( [_| _],[]) :- nb_delete(robotsPos).
move( _, [] ) :- !.
%        ^
%        |
%        Action: next configuration 

	move( [TL, TR, BL, BR, 0, BX, BY, GX, GY, YX, YY, RX, RY],Path) :-element(0, X, Y, TL, TR, BL, BR),
init(_), obstacle(OX,OY,TL,TR,BL,BR,_),nb_setval(le_Chemin,[OX,OY]),testRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[X,Y]),selectPath(Path).
	move( [TL, TR, BL, BR, IdElement, BX, BY | _],Path) :- IdElement>=1, IdElement < 5, init(_), element(IdElement, X, Y, TL, TR, BL, BR),nb_setval(color,0), obstacle(OX,OY,TL,TR,BL,BR,_),
nb_setval(le_Chemin,[OX,OY]),selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[RobotX, RobotY]),distance([RobotX, RobotY],[X, Y],C),a_star([[RobotX, RobotY],0,C,-1],[[X, Y],_,0,_],Path).

	move( [TL, TR, BL, BR, IdElement, BX, BY | _],Path) :- IdElement>=5, IdElement < 9, init(_), element(IdElement, X, Y, TL, TR, BL, BR),nb_setval(color,1), obstacle(OX,OY,TL,TR,BL,BR,_),
nb_setval(le_Chemin,[OX,OY]),selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[RobotX, RobotY]),distance([RobotX, RobotY],[X, Y],C),a_star([[RobotX, RobotY],0,C,-1],[[X, Y],_,0,_],Path).

	move( [TL, TR, BL, BR, IdElement, BX, BY | _],Path) :- IdElement>=9, IdElement < 13, init(_), element(IdElement, X, Y, TL, TR, BL, BR),nb_setval(color,2), obstacle(OX,OY,TL,TR,BL,BR,_),
nb_setval(le_Chemin,[OX,OY]),selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[RobotX, RobotY]),distance([RobotX, RobotY],[X, Y],C),a_star([[RobotX, RobotY],0,C,-1],[[X, Y],_,0,_],Path).

	move( [TL, TR, BL, BR, IdElement, BX, BY | _],Path) :- IdElement>=13, IdElement < 16, init(_), element(IdElement, X, Y, TL, TR, BL, BR),nb_setval(color,3), obstacle(OX,OY,TL,TR,BL,BR,_),
nb_setval(le_Chemin,[OX,OY]),selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[RobotX, RobotY]),distance([RobotX, RobotY],[X, Y],C),a_star([[RobotX, RobotY],0,C,-1],[[X, Y],_,0,_],Path).

%move( [_, _, _, _, T, BX, BY, GX, GY, YX, YY, RX, RY | _],[]):- T>=1, T < 5,  nb_setval(robotsPos,[ [GX, GY],[YX, YY],[RX, RY]]).
%move( [_, _, _, _, T, BX, BY, GX, GY, YX, YY, RX, RY | _],[]):- T>=5, T < 9, nb_setval(robotsPos,[[BX, BY],[YX, YY],[RX, RY]]).
%move( [_, _, _, _, T, BX, BY, GX, GY, YX, YY, RX, RY | _],[]):- T>=9, T < 13, nb_setval(robotsPos,[[BX, BY],[GX, GY],[RX, RY]]).
%move( [_, _, _, _, T, BX, BY, GX, GY, YX, YY, RX, RY | _],[]):- T>=13, T < 16, nb_setval(robotsPos,[[BX, BY],[GX, GY],[YX, YY]]).

%move( [TL, TR, BL, BR, _, BX, BY | _],[]) :- deplacement(BX, BY, 1, NX, NY, TL, TR, BL, BR, N),   writef('Coordonnees du robot: [%t , %t] / Obstacle : [%t, %t] / Deplacement de %t case(s) \n', [BX, BY, NX, NY, N]), !.
% move( [TL, TR, BL, BR | _],[]) :- writef('TL:%t TR:%t BL:%t BR:%t \n',[TL, TR, BL, BR]), !.

selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[BX,BY]):- nb_getval(color,0),!,nb_setval(r1,[GX,GY]),nb_setval(r2,[YX,YY]),nb_setval(r3,[RX,RY]).
selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[GX,GY]):- nb_getval(color,1),!,nb_setval(r1,[BX,BY]),nb_setval(r2,[YX,YY]),nb_setval(r3,[RX,RY]).
selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[YX,YY]):- nb_getval(color,2),!,nb_setval(r1,[BX,BY]),nb_setval(r2,[GX,GY]),nb_setval(r3,[RX,RY]).
selectRobot([BX,BY],[GX,GY],[YX,YY],[RX,RY],[RX,RY]):- nb_getval(color,3),!,nb_setval(r1,[BX,BY]),nb_setval(r2,[GX,GY]),nb_setval(r3,[YX,YY]).

	
blocked([ _,  0], 2):-!.
blocked([ _, 15], 4):-!.
blocked([15,  _], 1):-!.
blocked([ 0,  _], 3):-!.

blocked([X,Y],2):-Y1 is Y-1, nb_getval(r1,[X,Y1]),!.
blocked([X,Y],2):-Y1 is Y-1, nb_getval(r2,[X,Y1]),!.
blocked([X,Y],2):-Y1 is Y-1, nb_getval(r3,[X,Y1]),!.

blocked([X,Y],4):-Y1 is Y+1, nb_getval(r1,[X,Y1]),!.
blocked([X,Y],4):-Y1 is Y+1, nb_getval(r2,[X,Y1]),!.
blocked([X,Y],4):-Y1 is Y+1, nb_getval(r3,[X,Y1]),!.

blocked([X,Y],3):-X1 is X-1, nb_getval(r1,[X1,Y]),!.
blocked([X,Y],3):-X1 is X-1, nb_getval(r2,[X1,Y]),!.
blocked([X,Y],3):-X1 is X-1, nb_getval(r3,[X1,Y]),!.

blocked([X,Y],1):-X1 is X+1, nb_getval(r1,[X1,Y]),!.
blocked([X,Y],1):-X1 is X+1, nb_getval(r2,[X1,Y]),!.
blocked([X,Y],1):-X1 is X+1, nb_getval(r3,[X1,Y]),!.

blocked(Pos,Dir):-nb_getval(le_chemin,LWall),blocked(Pos,Dir,LWall).

blocked(Pos,2,[_,[Pos|_]]):-!.
blocked(Pos,2,[A,[_|R]]):-blocked(Pos,2,[A,R]),!.

blocked([X,Y],4,[_,[[X,Y1]|_]]):-Y1 is Y+1,!.
blocked(Pos,4,[A,[_|R]]):-blocked(Pos,4,[A,R]),!.

blocked(Pos,3,[[Pos|_],_]):-!.
blocked(Pos,3,[[_|R],A]):-blocked(Pos,3,[R,A]),!.

blocked([X,Y],1,[[[X1,Y]|_],_]):- X1 is X+1,!.
blocked(Pos,1,[[_|R],A]):-blocked(Pos,1,[R,A]),!.

testRobot(BPos,GPos,YPos,RPos,TPos):-
	nb_setval(color,0),
	selectRobot(BPos,GPos,YPos,RPos,RP),
	distance(RP,TPos,D),
	a_star([RP,0,D,-1],[TPos,_,0,_],Path),
	nb_getval(le_Chemin,LPath),
	append([Path],LPath,NewLPath),
	nb_setval(le_Chemin,NewLPath).
	
testRobot(BPos,GPos,YPos,RPos,TPos):-
	nb_setval(color,1),
	selectRobot(BPos,GPos,YPos,RPos,RP),
	manhattan(RP,TPos,D),
	a_star([RP,0,D,-1],[TPos,_,0,_],Path),
	nb_getval(le_Chemin,LPath),
	append([Path],LPath,NewLPath),
	nb_setval(le_Chemin,NewLPath).
	
testRobot(BPos,GPos,YPos,RPos,TPos):-
	nb_setval(color,2),
	selectRobot(BPos,GPos,YPos,RPos,RP),
	manhattan(RP,TPos,D),
	a_star([RP,0,D,-1],[TPos,_,0,_],Path),
	nb_getval(le_Chemin,LPath),
	append([Path],LPath,NewLPath),
	nb_setval(le_Chemin,NewLPath).

testRobot(BPos,GPos,YPos,RPos,TPos):-
	nb_setval(color,3),
	selectRobot(BPos,GPos,YPos,RPos,RP),
	manhattan(RP,TPos,D),
	a_star([RP,0,D,-1],[TPos,_,0,_],Path),
	nb_getval(le_Chemin,LPath),
	append([Path],LPath,NewLPath),
	nb_setval(le_Chemin,NewLPath).
	
	
/*move( _, [] ) :- !.
%        ^
%        |
%        Action: next configuration*/

selectPath(Path):-nb_getval(le_Chemin,LPath),
				selectPath(LPath,Path).
				
selectPath([P0|[]],P0).
selectPath([P0|R],P0):-
			selectPath(R,P1),
			nbElement(P0,N0),
			nbElement(P1,N1),
			N0<N1.
selectPath([P0|R],P1):-
			selectPath(R,P1),
			nbElement(P0,N0),
			nbElement(P1,N1),
			N0>=N1.
					
nbElement([],0).					
nbElement([_|R],N):-nbElement(R,N1),N is (N1 + 1).

% distance calcul la distance manhattan entre deux points (en coordonnées x,y).

distance([],[],0).
distance([A,B],[A,B],0).
distance([A1,B1],[A2,B2],C):- C is (abs(A1-A2)+abs(B1-B2)).

% Fonction f qui calcul le cout courant du chemin + la distance manhattan restante
% Argument1 : point précédant à N-1; Argument2 : point courant exploré N; Argument3 : point final; A : distance parcouru lors de la solution N-1; R : cout total

f([],[],[],0,0).
f([X1,Y1], [X1,Y1], [X2,Y2], A, A).
f([X1,Y1], [X2,Y2], [X3,Y3], A, R):- g([X1,Y1],[X2,Y2],A, B), distance([X2,Y2], [X3,Y3], C), R is B+C.

% Permet de parourir la liste et d'afficher les coordoonnées X,Y

parcours_liste([X,Y|R], [X,Y]).
parcours_liste([X1,Y1|R], [X2,Y2]):- parcours_liste(R, [X2,Y2]).


% On insère tous les noeuds dans la list openList
		
insertAllStatesInOpenList(_,_,[]).
insertAllStatesInOpenList([PositionPere,G,_,_],[PositionBalise,_,0,_],[PositionRobot|A]):-
                distance(PositionRobot,PositionBalise,H), 
                G1 is G+1, 
                nb_getval(openList,OpenList2),                 
                insererAvecTri([PosisionRobot, G1, H, PositionPere],OpenList2,OpenList3),
                nb_setval(openList,OpenList3),
                insertAllStatesInOpenList([PositionPere,G,_,_],[PositionBalise,_,0,_],A).

% On insère un noeud dans une liste en le positionnant à la bonne place (tri croissant selon le cout du noeud)
% Utilisé avec la liste closedList
				
insererAvecTri([], A, A).
insererAvecTri(A,[],[A]):-!. 
insererAvecTri([[X1,Y1],G1,H1,P1],[[[X2,Y2],G2,H2,P2]|L],[[[X1,Y1],G1,H1,P1],[[X2,Y2],G2,H2,P2]|L]):- H1+G1 =< H2+G2, !. 
insererAvecTri([[X1,Y1],G1,H1,P1],[[[X2,Y2],G2,H2,P2]|L],[[[X2,Y2],G2,H2,P2]|L1]):- G1+H1>G2+H2, insererAvecTri([[X1,Y1],G1,H1,P1],L,L1), !. 

% On test la position du robot. True : Il est sur l'objectif; False : il ne l'est pas

robot_sur_objectif([X1,Y1], [X2,Y2]):- X1 =:= X2, Y1 =:= Y2.

% Permet d'afficher le contenue de ClosedList

affiche_solution(closedList, A):- parcours_liste(closedList, A).

% On regarde si le robot est sur l'objectif. True : On affiche le contenue de closedList; False : On continue de chercher le meilleur noeud fils
% Incomplet

si_robot_sur_objectif([X1,Y1], [X3,Y3], openList, closedList, Cout, A):- robot_sur_objectif([X1,Y1],[X3,Y3]), !, affiche_solution(Closed, A).

% Algorithme A*

a_star([PositionBalise, 0, 0, -1], [PositionBalise,_, 0,_], []).
a_star(State1, State2, Path):-nb_getval(openList, []),!, nb_setval(openList, [State1]), a_star(State2, Path).

a_star(_,_):- nb_getval(openList, []), !, fail.
a_star([PosotionBalise, _, 0, _], Path):- getBestNodeFromOpenList([PositionBalise,_,0,_]), !, buildPath(Path).
a_star(State2, Path):- 
        extractBestNodeFromOpenList(Noeud),
        completerClosed(Noeud), 
        getAllAccessibleStates(Noeud, AccessibleStatesList), 
        insertAllStatesInOpenList(Noeud, State2, AccessibleStatesList),
        a_star(State2, Path).
 
% Retourne le noeud de openList avec le plus petit cout

getBestNodeFromOpenList(Noeud):- nb_getval(openList, [Noeud|_]).

completerClosed(Noeud):- nb_getval(closedList, ValeurClosed), append([Noeud], ValeurClosed, ClosedList2),nb_setval(closedList, ClosedList2).

% Meme chose mais on supprime le noeud visité de la liste openList

extractBestNodeFromOpenList(noeud):- nb_getval(openList,[noeud|R]), nb_setval(openList, R).

% Retourne le chemin à suivre dans la forme donnée par le sujet
% Part du noeud fin pour reconstruire le chemin
% Incomplet

buildPath(Path):-
	getBestNodeFromOpenList([PositionBalise,_,_,Var]), 
	buildPath(PositionBalise,Var,CheminALEnver),
	inverse(CheminALEnver, Chemin),
	nb_getval(color,C),
	solutionRetenue(Chemin,C,Path).

buildPath(_,-1,[]).	
	
buildPath(PositionBalise,Var1,Path):-
	direction(PositionBalise,Var1,D),
	append([D],Var3,Path),
	nb_getval(closedList,ClosedList2),
	member([Var1,_,_,Var2],ClosedList2),
	buildPath(Var1,Var2,Var3).
	
	
% Retourne tous les états accessibles depuis l'état actuel puis les évalues selon leur cout.

getAllAccessibleStates([X,Y,_,_,_], AccessibleStatesList):-
		deplacement([X,Y,1,NX1,NY1,_,_,TL, TR, BL, BR,_]),
        deplacement([X,Y,2,NX2,NY2,_,_,TL, TR, BL, BR,_]),
        deplacement([X,Y,3,NX3,NY3,_,_,TL, TR, BL, BR,_]),
        deplacement([X,Y,4,NX4,NY4,_,_,TL, TR, BL, BR,_]),
        evaluation([[NX1,NY1],[NX2,NY2],[NX3,NY3],[NX4,NY4]],AccessibleStatesList).

% Permet d'évaluer le meilleur successeur à partir d'un état.
% Incomplet
		
evaluation(Possibilite, AccessibleStatesList):-
		nb_getval(openList,OpenList2),
		nb_getval(closedList,ClosedList2),
		etudeDeCas(Possibilite,OpenList2,ClosedList2,AccessibleStatesList).
		
		
		
inverse([],[]).
inverse([A,B],[A,B]).
inverse([A,B|R],I1):-inverse(R,I2), append(I2,[A,B],I1).

solutionRetenue([],_,[]).
solutionRetenue([A1,B1|R],C,SR1):-append([[C,[A1,B1]],SR2],SR1),solutionRetenue(R,C,SR2),!.

	
direction([X1,_],[X2,_],Dir) :- X1>X2 , Dir is 1,!.
direction([_,Y1],[_,Y2],Dir) :- Y1<Y2 , Dir is 2,!.
direction([X1,_],[X2,_],Dir) :- X1<X2 , Dir is 3,!.
direction([_,Y1],[_,Y2],Dir) :- Y1>Y2 , Dir is 4,!.
		
etudeDeCas([],_,_,[]):-!.

etudeDeCas([[A,B]|R],[],[],accessibleStatesList):-append([A,B],accessibleStatesList2,accessibleStatesList),
			nb_getval(openList,OpenList2),nb_getval(closedList,ClosedList2),
			etudeDeCas(R,OpenList2,ClosedList2,accessibleStatesList2),!.
			
etudeDeCas([[A,B]|R],[],[[[A,B],_,_,_]|_],accessibleStatesList):-
			nb_getval(closedList,ClosedList2),nb_getval(openList,OpenList2),
			etudeDeCas(R,OpenList2,ClosedList2,accessibleStatesList),!.
			
etudeDeCas([[A,B]|R1],[],[_|R2],accessibleStatesList):-
			etudeDeCas([[A,B]|R1],[],R2,accessibleStatesList),!.
			
etudeDeCas([[A,B]|R1],[[[A,B],_,_,_]|_],closedList,accessibleStatesList):-
			nb_getval(openList,OpenList2),
			etudeDeCas(R1,OpenList2,closedList,accessibleStatesList).
			
etudeDeCas([[A,B]|R1],[_|R2],closedList,accessibleStatesList):-
			etudeDeCas([[A,B]|R1],R2,closedList,accessibleStatesList).
			
